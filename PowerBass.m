/* vim: set syntax=magma :*/

//freeze;

/////////////////////////////////////////////////////
// Modules over Bass Orders 
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

declare verbose PowerBass, 1;

/* 
In this package we defined the type BassMod which consist of an R-Module M living inside an algebra A isormophic to a power of Algebra(R).
If the order R is Bass this module can be written as a direct sum of fractional ideals:
M = J1v1+J2v2+...+Jsvs, where the vi are elements of A.
Again, if R is Bass we compute representatives al all R-isomorphismc classes of such modules and we can determine whether two of such modules are isorphic.

NOTES
- check if the part where I force the multiplicatorring of J to be the one of M is really necessary;
+ YES, IT IS.
- if so, optimize it (the random process with the matrix rU is very inefficient and often one needs to increase the size of the coefficients.)

TODO check that the homs returned are R-linear

*/


// ------------------- //
// Type BassMod
// ------------------- //

declare type BassMod;
declare attributes BassMod : UniverseAlgebra, // the algebra where the modules lives in
                             Order, // a pair <R,m> where R is Bass order and m:R->UniverseAlgebra
                             GensOverZ, // a ZBasis of the module. these elements are in the UniverseAlgebra
                             DirectSumRep, // a sequence of pairs <J,m> where J is a practional R ideal and m:Algebra(R)->UniverseAlgebra, such that the module equals J1*m1(One(R))+...+Js*ms(One(R)) where the sum is direct. Also (Ji:Ji) subseteq (Ji+1:Ji+1)  
                             SteinitzClass, // the ideal J1*J2*...*Js of the above decomposition
                             StdDirectSumRep, // < seq,map >, where seq is a sequence of pairs <Si,ei> with ei an orthogonal idempotent of the UniverseAlgebra UA and Si is the multiplicator ring of Ji (from the direct sum decomposition) for i = 1,...,s-1 and Ss is the SteinitzClass. map:UA->UA sends the DirectSumRep into seq.
                             MultiplicatorRing; // the multiplicator ring of the module, that is, the biggest over-order S of R for which M is an S-module

intrinsic UniverseAlgebra( M::BassMod )->AlgAss
{ returns the algebra where the modules lives in }
    return M`UniverseAlgebra;
end intrinsic;

intrinsic Order( M::BassMod)->AlgAssVOrd,Map
{ returns the order over which the module is defined and a map describing the UniverseAlgebra as an R-module  }
    R:=M`Order[1];
    map:=M`Order[2];
    return R,map;
end intrinsic;

intrinsic GensOverZ( M::BassMod)->SeqEnum[AlgAssElt]
{ returns a ZBasis of the module M }
    return M`GensOverZ;
end intrinsic;

intrinsic Print( M::BassMod )
{ print the Bass module }
    printf "module over %o generated by %o",Order(M),GensOverZ(M);
end intrinsic;

// ------------------- //
// Creation of BassMod
// ------------------- //

intrinsic BassModule( R::AlgAssVOrd, m::Map, gens::SeqEnum[AlgAssElt] )->BassMod
{ given a Bass order R, a map m:Algebra(R)->A, where A is an algebra containing the sequence gens, it returns the R-sub-module of A generated by gens. It computes the DirectSumRep. }
    UA:=Codomain(m);
    assert m(One(Algebra(R))) eq One(UA);
    require Algebra(R) eq Domain(m) : "the map does not have Algebra(R) as codomain";
    require forall{g : g in gens | Parent(g) eq UA } : "the generators do not live in Codomain(m)";
    require Dimension(UA) eq Rank(Matrix([ ChangeUniverse(Eltseq(g) , Rationals()) : g in gens ])) : "gens do not generater a Z-module of full rank";
    // here we do not require the order to be bass
    M:=New(BassMod);
    M`UniverseAlgebra:=UA;
    M`Order:=<R,m>;
    M`GensOverZ:=gens;
    // the DirectSumRep is computed only if required 
    return M;
end intrinsic;

intrinsic BassModule( R::AlgAssVOrd, m::Map, frac_ideals::SeqEnum[AlgAssVOrdIdl] )->BassMod
{  given a Bass order R, a map m:Algebra(R)->A, where A is an alggebra, and a sequence of fractrional R-ideals [I1,...Is] , it returns the R-sub-module of A equal to the direct sum I1+...+Is.}
    UA:=Codomain(m);
    AR:=Algebra(R);
    dimR:=Dimension(AR);
    assert m(One(AR)) eq One(UA);
    require AR eq Domain(m) : "the map does not have Algebra(R) as codomain";
    require forall{I : I in frac_ideals | Order(I) eq R } : "the fractional ideals are not R ideals";
    require Dimension(UA) eq dimR*#frac_ideals : "the fractional ideals do not generate a Z-module of full rank";
    // here we do not require the order to be bass
    M:=New(BassMod);
    M`UniverseAlgebra:=UA;
    M`Order:=<R,m>;
    gens:=[];
    dsr:=[];
    for i in [1..#frac_ideals] do
        i0:=(i-1)*dimR;
        assert (UA.(i0+1))^2 eq UA.(i0+1); //this element should be idempotent
        I:=frac_ideals[i];
        mi:=hom<Algebra(R)->UA | [ UA.(i0+j) : j in [1..dimR] ]>; // One(R) to the ith component
        gens cat:= [ mi(z) : z in ZBasis(I) ];
        Append(~dsr, <I,mi>);
    end for;
    M`GensOverZ:=gens;
    M`DirectSumRep:= dsr;
    return M;
end intrinsic;

intrinsic BassModule( R::AlgAssVOrd, m::Map, seq::SeqEnum[Tup] )->BassMod
{   Let R be a Bass and a map m:Algebra(R)->A, where A is an algebra isomorphic to Algebra(R)^s.
    Let seq be a sequence of pairs <J,v> where J is a fractional R ideal and v is either an elemtn of A or a map v:Algebra(J)->A. 
    The function returns the BassMod M=J1v1+J2v2+...Jsvs (in the first case) or J1v1(1)+...+Jsvs(1) (in the second case).
}
    AR:=Algebra(R);
    UA:=Codomain(m);
    assert m(One(AR)) eq One(UA);
    require AR eq Domain(m) : "the map does not have Algebra(R) as codomain";
    require forall{I : I in seq | Order(I[1]) eq R } : "the fractional ideals are not R ideals";
    if forall{I : I in seq | Type(I[2]) eq Map } then
        require forall{I : I in seq | Domain(I[2]) eq AR and Codomain(I[2]) eq UA } : "the sequence is not valid for this constructor";
        //in this case the given seq is the DirectSumRep of the module
        gens:=&cat[ [ I[2](z) : z in ZBasis(I[1]) ] : I in seq ];
        dsr:=seq;
    elif forall{I : I in seq | Type(I[2]) eq AlgAssElt } then 
        require forall{I : I in seq | Parent(I[2]) eq UA } : "the sequence is not valid for this constructor";
        dsr:=[];
        // TODO add check that the sum is direct 
        gens:=[];
        for I in seq do 
            mI:=hom< AR->UA | [m(AR.i)*I[2] : i in [1..Dimension(AR)] ]  >;  //map that sends one to I[2] 
            Append(~dsr,<I,mI>);
            gens cat:=[ mI(z) : z in ZBasis(I[1]) ];
        end for;
    else
        error "the sequence is not valid for this constructor";
    end if;
    require Dimension(UA) eq Rank(Matrix([ ChangeUniverse(Eltseq(g) , Rationals()) : g in gens ])) : "gens do not generater a Z-module of full rank";
    M:=New(BassMod);
    M`UniverseAlgebra:=UA;
    M`Order:=<R,m>;
    // here we do not require the order to be bass
    M`GensOverZ:=gens;
    M`DirectSumRep:=dsr;
    return M;
end intrinsic;

// ------------------- //
// functions for equality testing.
// ------------------- //

isMeqN_ZBasis:=function(gensM,gensN)
// input: two sequence of Qvectors
// returns: whether the vectors generate the same Z-module
    M_mat:=Matrix(gensM);
    N_mat:=Matrix(gensN);
    d_M:=Denominator(M_mat);
    d_N:=Denominator(N_mat);
    if not d_M eq d_N then 
    	return false;
    else
	    M_matZ:=ChangeRing(d_M*M_mat,Integers()); 
	    N_matZ:=ChangeRing(d_N*N_mat,Integers());
	    HNF_M:=Matrix([r : r in Rows(HermiteForm(M_matZ)) | not IsZero(r)]);
	    HNF_N:=Matrix([r : r in Rows(HermiteForm(N_matZ)) | not IsZero(r)]);
	    return HNF_M eq HNF_N;
    end if;
end function;

isMeqN_KBasis:=function(gensM,gensN)
// input: two sequence of Kvectors
// returns: whether the vectors generate the same Z-module
    gensM_Q:=[&cat[ ChangeUniverse(Eltseq(v),Rationals()) : v in g ] : g in gensM];  
    gensN_Q:=[&cat[ ChangeUniverse(Eltseq(v),Rationals()) : v in g ] : g in gensN];  
    return isMeqN_ZBasis(gensM_Q,gensN_Q);
end function;

isUAeq:=function(gensM,gensN)
// given generators in the Universal Algebra, we check if they generate the same Z-module
    return isMeqN_ZBasis(
            [ ChangeUniverse(Eltseq(g),Rationals()) : g in gensM ], 
            [ ChangeUniverse(Eltseq(g),Rationals()) : g in gensN ]
                );
end function;

intrinsic 'eq'(M1::BassMod,M2::BassMod)->BoolElt
{ equality testing for BassMod.}
    require UniverseAlgebra(M1) eq UniverseAlgebra(M2) and Order(M1) eq Order(M2) : "the modules do not live in the same UniverseAlgebra ";
    return isUAeq(GensOverZ(M1),GensOverZ(M2));
end intrinsic;


// ------------------- //
// Multiplicator Ring
// ------------------- //

intrinsic MultiplicatorRing( M::BassMod)->AlgAssVOrd
{ returns the multiplicator ring of the module, that is, the biggest over-order S of R for which M is an S-module }
    if not assigned M`MultiplicatorRing then
        if assigned M`DirectSumRep then
            mult_rings:=[ MultiplicatorRing(J[1]) : J in M`DirectSumRep ];
            assert exists(mr){ T : T in mult_rings | forall{ S : S in mult_rings | T subset S }  }; //is the smallest of the multiplicator rings
            assert mr in mult_rings;
            M`MultiplicatorRing:=mr;
        else
            gens:=GensOverZ(M);
            //TODO use linear algebra
            R,map:=Order(M);
            oo:=FindOverOrders(R);
            oo1:=[ S : S in oo | isUAeq( [ g*map(s) : s in ZBasis(S) , g in gens ] cat gens , gens ) ];
            mr:=Order(&cat[ZBasis(S) : S in oo1]);
            assert mr in oo;
            M`MultiplicatorRing:=mr;
        end if;
    end if;
    return M`MultiplicatorRing;
end intrinsic;

// ------------------- //
// DirectSumRep
// ------------------- //
// TODO: clean the code and try to substitute the randomized parts with a deterministic search

multiplicator_ring_internal:=function(gens, R)
//given gens:=[ g1, g2, ..., gs ] where each gi is a sequence of elements of some algebra Ag, it returns the multiplicator ring of the R-module generated by gens. this is searched among the over-orders of R
    oo:=FindOverOrders(R);
    oo1:=[ S : S in oo | isMeqN_KBasis( [ [ gi*s : gi in g ] : s in ZBasis(S) , g in gens ] cat gens , gens ) ];
    mr:=Order(&cat[ZBasis(S) : S in oo1]);
    assert mr in oo;
    return mr;
end function;


bass_factor:=function(gens_input,Rg)
// Input: 
// - gens_input is a sequence of vectors in Ag^s generating as a Z-basis an Rg-module I, where Ag is the fraction field of Rg.
// - Rg : see above
// Output: <J,v>,gens_I0 where J is a fractional Rg-ideal and I=Jv \oplus I0.
// v is returned as a sequence of elements of Ag.
    Ag:=Algebra(Rg);
    n:=Dimension(Ag);
    s0:=Rank(Matrix(gens_input));
    assert Parent(gens_input[1,1]) eq Ag;
    gensZ:=[ &cat[ChangeUniverse(Eltseq(xi),Rationals()) : xi in g] : g in gens_input ];
    T:=multiplicator_ring_internal(gens_input,Rg);
    //change gens into a Z-equivalent set in such a way that the ideal J=(proj on the first copy of Ag) satisfies (J:J)=T. A priori (J:J) might be bigger
    //TODO improve this part : remove the randomized part
    k1:=1;
    tt:=false;
    rU:=IdentityMatrix(Rationals(),#gensZ[1]);
    repeat
        for k2 in [1..100] do
            gensZ_new:=[Eltseq(r) : r in Rows(rU*Matrix(gensZ))];
            gens:=[[Ag!Eltseq(g)[i*n+1..(i+1)*n] : i in [0..s0-1]] : g in gensZ_new];
            for ui in [1..#gens] do
                u1:=gens[ui];
                abssquare_u1:=&+[u1[j]*u1[j] : j in [1..#u1] ];
                gens_J:=[(&+[g[j]*u1[j] : j in [1..#u1] ])/abssquare_u1 : g in gens];
                J:=ideal<Rg|gens_J>;
                S:=MultiplicatorRing(J);
                assert T subset S;
                if S eq T then
                    SwapElements(~gens,1,ui);
                    tt:=true;
                    break k2;
                end if;
            end for;
            rU:=ChangeRing(RandomUnimodularMatrix(#gensZ[1],10^k1),Rationals());
        end for;
    k1+:=1;
    until tt; //tt=true if S eq T
    Jinv:=ColonIdeal(S,ideal<S|ZBasis(J)>);
    gens_IJinv:=&cat[[[ j*gi : gi in g ] : g in gens] : j in ZBasis(Jinv)];
    coeffsu1_IJinv:=[ChangeUniverse(Eltseq(&+[g[j]*u1[j] : j in [1..#u1]]/abssquare_u1 ),Rationals()) : g in gens_IJinv]; //as Qvectors
    assert ideal<Rg|[Ag ! s : s in coeffsu1_IJinv]> eq ideal<Rg|ZBasis(S)>;
    A:=Matrix(coeffsu1_IJinv);
    d_A:=Denominator(A);
    AZ:=ChangeRing(d_A*A,Integers());
    assert #Rows(AZ) eq #gens_IJinv;
    vect:=Vector([ d_A ] cat [0 : i in [1..n-1] ]);
    coeffs_v:=Solution(AZ,vect);
    v:=Eltseq(&+Rows(ChangeRing(DiagonalMatrix(Eltseq(coeffs_v)),Ag)*Matrix(gens_IJinv)));
    assert (&+[v[i]*u1[i] : i in [1..s0]]/abssquare_u1) eq 1;
    assert isMeqN_KBasis([v] cat gens_input,gens_input);
    // def I0=Jinv*M0, where M0 is the set of elements of I*Jinv such that the projection on u1 is 0, that is M0=ker(I*Jinv ->> S*u1)    
    gensZ_IJinv:=[ [Rationals() ! y : y in &cat[Eltseq(x) :x in g]] :g in  gens_IJinv];
    mat:=Matrix([ChangeUniverse(Eltseq(h),Rationals()) : h in [ &+[g[i]*u1[i] : i in [1..#u1]]: g in gens_IJinv ]]);
    den:=Denominator(mat);
    mat:=ChangeRing(den*mat,Integers());
    s,ker:=Solution(mat,Vector([0 : i in [1..NumberOfColumns(mat)]]));
    assert IsZero(s); //Zero is always a solution, s needs to be Zero. If that is not the case I need to modify the generators of M0 accordingly
    gensZ_M0:=Rows(ChangeRing(Matrix(Basis(ker)),Rationals())*Matrix(gensZ_IJinv));
    //M0 is generated by ker over Z.    
    gens_M0:=[[Ag!Eltseq(g)[i*n+1..(i+1)*n] : i in [0..s0-1]] : g in gensZ_M0];
    if forall{ g : g in gens_M0 | forall{gi : gi in g | IsZero(gi)} } then 
        gens_I0:=[];
    else
        //I0 = J*M0
        gens_I0:=[ [mi*j : mi in m] : m in gens_M0 , j in gens_J ];
        mat_gensZ_I0:=Matrix([ &cat[ChangeUniverse(Eltseq(xi),Rationals()) : xi in g] : g in gens_I0 ]);
        den:=Denominator(mat_gensZ_I0);
        matHNF_gensZ_I0:=(1/den)*ChangeRing(Matrix([r : r in Rows(HermiteForm(ChangeRing(den*mat_gensZ_I0,Integers()))) | not IsZero(r)]),Rationals());
        gensZ_I0:=[Eltseq(r) : r in Rows(matHNF_gensZ_I0)];
        gens_I0:=[[Ag!Eltseq(g)[i*n+1..(i+1)*n] : i in [0..s0-1]] : g in gensZ_I0];
//TEST//
gens_Jv:=[[vi*j : vi in v] : j in ZBasis(J)];
assert isMeqN_KBasis(gens_I0 cat gens_Jv,gens_input);
assert #gens_I0 eq #gens - n;
gensZ_input:=[ &cat[ChangeUniverse(Eltseq(xi),Rationals()) : xi in g] : g in gens_input ];
assert Rank(Matrix(gensZ_I0)) eq Rank(Matrix(gensZ_input))-n;
assert Rank(Matrix(gens_I0)) eq Rank(Matrix(gens_input))-1;
end if;
//END TEST//    
    return <J,v>,gens_I0;
end function;

intrinsic DirectSumRep(M::BassMod)->SeqEnum[Tup]
{ returns a sequence of pairs <J,m> where J is a practional R ideal and m:Algebra(R)->UniverseAlgebra, such that M =  J1*m1(One(R))+...+Js*ms(One(R)) where the sum is direct. Also (Ji:Ji) subseteq (Ji+1:Ji+1) 
  }
    if not assigned M`DirectSumRep then    
        Rg,mR:=Order(M);
        Ag:=Algebra(Rg);
        n:=Dimension(Ag);
        UA:=UniverseAlgebra(M);
        if IsBass(Rg) then
            T:=MultiplicatorRing(M);
            gensZ:=GensOverZ(M);
            AgstoUA:=func< v | UA!&cat[Eltseq(vi) : vi in v] >;
            UAtoAgs:=func< x | [Ag!p : p in Partition(Eltseq(x),Dimension(Ag))]  >;
            gens:=[ UAtoAgs(g) : g in gensZ ] ;
            gens_loop:=gens;
            mat_BaseChange:=IdentityMatrix(Ag,#gens[1]);
            bass_decompI:=[];
            repeat
                bc_fac,gens_I0:=bass_factor(gens_loop,Rg);        
                J:=bc_fac[1];
                v0:=bc_fac[2];
                v:=Eltseq(Vector(v0)*mat_BaseChange);
                assert isMeqN_KBasis(gens cat [[vi*zbJ : vi in v]  : zbJ in ZBasis(J)],gens); //is v*J in M? 
                Append(~bass_decompI,<J,v>);
                //now gensI0 genreate a Zmodule of rank = rank(gens)-n. I need to rearrange them in a such a way that all zeros are in one column
                //TODO remove the randomization
                if #gens_I0 ne 0 then  
                    mI0:=Matrix(gens_I0);
                    rkI0:=Rank(mI0);
                    rowsI0:=Rows(mI0);
                    repeat
                        m1:=Matrix( [Random(rowsI0) : i in [1..rkI0]] );
                    until Rank(m1) eq rkI0;
                    gens_loop:=[Eltseq(r) : r in Rows(Solution( m1 , mI0 ))];
                    mat_BaseChange:=m1*mat_BaseChange;
                end if;
            until #gens_I0 eq 0;

            // TESTS //////////////////////////////////
                    gens_Test:=[];
                    for bc in bass_decompI do
                    J:=bc[1];
                    //"zbJ"; ZBasis(J);
                    v:=bc[2];
                    //"v"; v;
                    gens_Test:=gens_Test cat [  [j*vi : vi in v] : j in ZBasis(J) ];
                    end for;
                    //"gens"; gens; "gens_Test"; gens_Test;
                    assert isMeqN_KBasis(gens cat gens_Test,gens_Test);
                    // test using abelian groups. I will test also the intersections
                    gensZ:=[ &cat[Eltseq(gi) : gi in g] : g in gens ];
                    F:=FreeAbelianGroup(#gensZ[1]);
                    subs:=[];
                    for bc in bass_decompI do
                    J:=bc[1]; v:=bc[2];
                    gens_Jv:=[  [j*vi : vi in v] : j in ZBasis(J) ];
                    gensZ_Jv:=[ &cat[Eltseq(gi) : gi in g] : g in gens_Jv ];
                    mat_gensZ:=Matrix(Rationals() , gensZ);
                    mat_gensZ_Jv:=Matrix(Rationals() , gensZ_Jv);
                    den:=Denominator(VerticalJoin(mat_gensZ,mat_gensZ_Jv));
                    coordsZ_Jv:=Solution(ChangeRing(den*mat_gensZ,Integers()),ChangeRing(den*mat_gensZ_Jv,Integers()));
                    gensF_Jv:=[F!Eltseq(r) : r in Rows(coordsZ_Jv) ];
                    subF_Jv:=sub<F|gensF_Jv>;
                    Append(~subs,subF_Jv);
                    end for;
                    assert &+subs eq F; //the sum is ok
                    assert forall{H : H in subs | not exists{G : G in subs | G ne H and not IsTrivial(G meet H)}}; //the intersections are trivial, that is the sum is direct
            // END TESTS //////////////////////////////////////
            BC:= [ <bc[1],hom<Ag->UA| [mR(Ag.i)*AgstoUA(bc[2]): i in [1..Dimension(Ag)]]>> : bc in bass_decompI ];
            // more TEST //
            assert isUAeq( GensOverZ(M) , &cat[[ bc[2](z) : z in ZBasis(bc[1]) ] : bc in BC ]); // the sum is ok
            V,v:=VectorSpace(UA);
            subs:=[ sub<V| [ v(bc[2](z)) : z in ZBasis(bc[1])  ] > : bc in BC ];
            for W1,W2 in subs do assert ((W1 eq W2) or IsZero(Dimension(W1 meet W2))); end for; 
            assert forall{bc : bc in BC | Codomain(bc[2]) eq UA};
            M`DirectSumRep:=BC;
        elif n eq Dimension(UA) then //squarefree case
            M`DirectSumRep:=<ideal<Rg|GensOverZ(M)>,mR>;
        else
            error "implemented only for the squarefree or power-of-bass case";
        end if;
    end if;
    return M`DirectSumRep;
end intrinsic;

// ------------------- //
// Compute all BassModules up to isomorphism
// ------------------- //

chains_of_overorders:=procedure(r,~chain,~all_chains)
	if #chain eq r then 
		Append(~all_chains,chain); 
	else
		T:=chain[#chain];        
		for S in FindOverOrders(T) do
			chain1:=chain;
			Append(~chain1,S);
			$$(r,~chain1,~all_chains);
		end for;
	end if;
end procedure;

direct_sums_overorders:=function(R,r)
//given a (Bass) order R and a rank r, it returns all sequences S_1,..,S_r where R\subseteq S_
	choo:=<>;
	oo:=FindOverOrders(R);
	for S in oo do
		ch:=<S>;
		chains_of_overorders(r,~ch,~choo);
	end for;
	return choo;
end function;

intrinsic AllBassClasses(R::AlgAssVOrd, r::RngIntElt)->SeqEnum[BassMod]
{Given a Bass order R and a rank r, it returns representatives of all the isormorphism classes of torsion-free R modules of rank r}
	require IsBass(R) : "the first input must be a Bass order";  
	require r gt 0 : "the second input must be a positive integer";  
	output:=<>;
	choo:=direct_sums_overorders(R,r);
	for ch in choo do
		P,p:=PicardGroup(ch[r]);
		pic:=[p(g) : g in P];
		ch_rem:=Prune(ch);
		for I in pic do
			Append(~output,Append(ch_rem,I));
		end for;
	end for;
    output:=[ [ideal<R|ZBasis(I)> : I in t] : t in output ];
    AR:=Algebra(R);
    UA,emb:=DirectSum([ AR : i in [1..r]]);
    map:=hom< AR->UA|[ &+[e(AR.i) : e in emb] : i in [1..Dimension(AR)]] >;
    output:=[ BassModule(R,map, seq) : seq in output];
	return output;
end intrinsic;

intrinsic AllBassClasses(R::AlgAssVOrd, map::Map )->SeqEnum[BassMod]
{Given a Bass order R and a map:Algebra(R)->UA, it returns representatives of all the isormorphism classes of torsion-free R modules inside R. We need UA to be isomorphic to a power of Algebra(R) }
    require IsBass(R) : "the first input must be a Bass order";
    UA:=Codomain(map);
    Type(UA) eq AlgAss;
    AR:=Algebra(R);
    assert Dimension(UA) mod Dimension(AR) eq 0;
    r:=Dimension(UA) div Dimension(AR);
    output:=<>;
    choo:=direct_sums_overorders(R,r);
    for ch in choo do
        P,p:=PicardGroup(ch[r]);
        pic:=[p(g) : g in P];
        ch_rem:=Prune(ch);
        for I in pic do
            Append(~output,Append(ch_rem,I));
        end for;
    end for;
    output:=[ [ideal<R|ZBasis(I)> : I in t] : t in output ];
    output:=[ BassModule(R,map, seq) : seq in output];
    return output;
end intrinsic;

// ------------------- //
// SteinitzClass
// ------------------- //

intrinsic SteinitzClass(M::BassMod)->AlgAssVOrdIdl
{returns the product of the fractional ideals in the input}
    if not assigned M`SteinitzClass then
	    M`SteinitzClass:=&*[ D[1] : D in DirectSumRep(M) ];
    end if;
	return M`SteinitzClass;
end intrinsic; 

// ------------------- //
// StdDirectSumRep
// ------------------- //

std_Bass_map:=function(bc,UA)
// given a sequence I1,...,Ir of ideals of K it returns the hom:UA->UA that sends I1+...+Is to S1+...+Ss-1+I1*..*Is acting on column vectors
// with S1 Bass and S1 in S2 in S3 in ... in Ss-1 in Sr = (I1*...*Is:I1*...*Is)
    s:=#bc;
    AR:=Algebra(bc[1]);
    id:=IdentityMatrix(AR,s);
    M:=id;
    for i in [1..s-1] do
        I1:=bc[i];
        I2:=bc[i+1];
        S:=MultiplicatorRing(I1);
        c2I2,c2:=MakeIntegral(S!I2);
        c1,c1I1:=CoprimeRepresentative(S!I1,c2I2);
        a2:=ChineseRemainderTheorem(c1I1,c2I2,AR!1,AR!0);
        a1:=1-a2;
        Mi:=InsertBlock(id,Matrix(AR,2,2,[c1,-c2,a2/c2,a1/c1]),i,i); //acts on column vectors
        M:=Mi*M;
        bc[i+1]:=I1*I2; //this was missing
    end for;
    MT:=Transpose(M);
    UAtoARs:=func< x | [AR!p : p in Partition(Eltseq(x),Dimension(AR))]  >; //isom UA->AR^s
    ARstoUA:=func< v | UA!&cat[Eltseq(vi) : vi in v] >; // isom AR^s->UA
    images:=[ ARstoUA(Eltseq(Rows(Matrix(1,s,Matrix(1,s,UAtoARs(b))*MT))[1])) : b in Basis(UA) ];
    hom_id:=hom< UA->UA| images >;
    return hom_id;
end function;

intrinsic StdDirectSumRep(M::BassMod)->SeqEnum[Tup],Map
{ returns < seq,map >, where seq is a sequence of pairs <Si,ei> with:
    - ei:Algebra(R)->UA that sends 1_R to the ith orthogonal idempotent of the UniverseAlgebra UA, and
    - Si is the multiplicator ring of Ji (from the DirectSumRep) for i = 1,...,s-1 and Ss is the SteinitzClass.
      [ note : S1 in S2 in ... in Ss-1 in (Ss:Ss) ].
    - map:UA->UA is an R-linear morphism that sends the DirectSumRep into seq.
}
    if not assigned M`StdDirectSumRep then
        UA:=UniverseAlgebra(M);
        //oneUA:=One(UA);
        R,mR:=Order(M);
        AR:=Algebra(R);
        oneAR:=One(AR);
        dr:=Dimension(AR);
        DRS:=DirectSumRep(M);
        s:=#DRS;
        oid:= [ UA!&cat[ j eq c select Eltseq(AR!1) else Eltseq(AR!0) : j in [1..s]]  : c in [1..s]]; //Orthogonal idempotent
        assert #oid eq s;
        Si_s:=[ i lt s select ideal<R|ZBasis(MultiplicatorRing(DRS[i,1]))> else SteinitzClass(M) : i in [1..s] ]; 
        ei_s:=[ hom<AR->UA | [mR(b)*oid[i] : b in Basis(AR) ] > : i in [1..s] ];
        seq:=[ < Si_s[j],ei_s[j] > : j in [1..s ]];
        //now we build map:
        hom_id:=std_Bass_map([D[1] : D in DRS],UA);
        hom_vs:=Inverse(hom<UA->UA | &cat[ [mR(a)*D[2](oneAR) : a in Basis(AR)] : D in DRS ]>);
        map:=hom<UA->UA | [hom_id(hom_vs(b)) : b in Basis(UA)]>; // not as a composition to make it cleaner.
        M`StdDirectSumRep:=<seq,map>;
        // TEST 
//                gens_in:=&cat[[ mR(z)*D[2](oneAR) : z in ZBasis(D[1])] : D in DRS];
//                gens_std:=&cat[[ mR(z)*D[2](oneAR) : z in ZBasis(D[1])] : D in M`StdDirectSumRep[1]];
//                assert isUAeq(GensOverZ(M),gens_in);
//                //assert isUAeq([ map(g) : g in GensOverZ(M)],gens_std);
//                assert isUAeq([ map(g) : g in gens_in],gens_std);
        // end test
    end if;
	return M`StdDirectSumRep[1],M`StdDirectSumRep[2];
end intrinsic;

// ------------------- //
// Isomorphism testing for BassMod
// ------------------- //
intrinsic IsIsomorphic( M1::BassMod, M2::BassMod )->BoolElt,Map
{ returns wheter two BassMods M1 and M2 are isormophic and if so it returns also a map from the common universe algebra that sends M1 into M2.}    
    UA:=UniverseAlgebra(M1);
    R,mR:=Order(M1);
    AR:=Algebra(R);
    require UniverseAlgebra(M2) eq UA : "the BassModules don't live in the same algebra";
    require R eq Order(M2) : "the Bass Modules are not defiend over the same order";
    Std1,mStd1:=StdDirectSumRep(M1);   
    Std2,mStd2:=StdDirectSumRep(M2);
    s:=#Std1;
    test:=&and[ Std1[j,1] eq Std2[j,1] : j in [1..s-1] ];
    if test then
        test,x:=IsIsomorphic2(Std1[s,1],Std2[s,1]); // Std1[s]=x*Std2[s]
        if test then 
            UAtoARs:=func< x | [AR!p : p in Partition(Eltseq(x),Dimension(AR))]  >; //isom UA->AR^s
            ARstoUA:=func< v | UA!&cat[Eltseq(vi) : vi in v] >; // isom AR^s->UA
            images:=[ ARstoUA([ j lt s select UAtoARs(b)[j] else UAtoARs(b)[j]/x : j in [1..s]])  : b in Basis(UA) ];
            map_x:=hom<UA->UA|images>; 
            // TEST
//                  oneAR:=AR!1;
//                  gens1:=&cat[[ mR(z)*D[2](oneAR) : z in ZBasis(D[1])] : D in Std1 ];
//                  gens2:=&cat[[ mR(z)*D[2](oneAR) : z in ZBasis(D[1])] : D in Std2 ];
//                  assert isUAeq([map_x(g) : g in gens1] , gens2);
            // end test
            map:=hom<UA->UA| [ Inverse(mStd2)(map_x(mStd1(g))) : g in Basis(UA) ] > ;
            // TEST
            assert isUAeq([map(g) : g in GensOverZ(M1)] , GensOverZ(M2));
            // end test
            return true,map;
         else
            return false,_;
         end if;
    else
        return false,_;
    end if;
end intrinsic;       


/*
//TESTS

AttachSpec("packages.spec");
P<x>:=PolynomialRing(Integers());
f:=x^4 + 3*x^3 + 8*x^2 + 39*x + 169;
A:=AssociativeAlgebra(f);
F:=PrimitiveElement(A);
q:=Integers() ! (Coefficients(f)[1]^(2/Degree(f)));
R:=Order([F,q/F]);
ver:=[62,97,144,206,286];
res:=[ #AllBassClasses(R,i) : i in [1..5] ];
assert res eq ver;

P<x>:=PolynomialRing(Integers());
f:=x^6-x^5+2*x^4-2*x^3+4*x^2-4*x+8;
A:=AssociativeAlgebra(f);
F:=PrimitiveElement(A);
R:=Order([F,ComplexConjugate(F)]);
iso_cl:=AllBassClasses(R,3);
assert #iso_cl eq 6;

for M1,M2 in iso_cl do
    t,s:=IsIsomorphic(M1,M2);
end for;

*/

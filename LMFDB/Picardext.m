//freeze;

/////////////////////////////////////////////////////
// Picard Group of orders in etale algebras over \Q
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

import "usefulfunctions.m": AllPossibilities;
import "sorting/code/sorting.m": SplitPrime;

/*TODO:
-Discrete Log in ResidueRingUnits (is it necessary?)
*/

declare attributes AlgAssVOrd:PicardGroup;
declare attributes AlgAssVOrd:PicardGroup_LMFDB;
declare attributes AlgAssVOrd:UnitGroup;

function CoprimePart(n, e)
    while true do
        d := Gcd(n, e);
        if d eq 1 then
            return n;
        end if;
        n := n div d;
    end while;
end function;

function PrimePart(n, e)
    return n div CoprimePart(n, e);
end function;

intrinsic LMFDBGenerators(S::AlgEtQOrd) -> SeqEnum
{
This function chooses a generating set for the Picard group P of S in a canonical way.
Suppose the abelian invariants of P are m1 | m2 | ... | mk.  We choose prime ideals
Ik, ..., I2, I1 whose classes generate P and have orders mk, ..., m2, m1.

At each step, we find the smallest prime ideal of the correct order not in the span
of the already chosen ideals.  We order ideals first by norm, and then by the methods
described by Cremona, Page and Sutherland.

This process is guaranteed to terminate since the classes of prime ideals are
equidistributed in the class group (at least once the norm surpasses a small power of
the log of the discriminant)
}
    A := Algebra(S);
    O := MaximalOrder(A);
    F := Conductor(S);
    P, pmap := PicardGroup(S);
    b, O_asProd := IsProductOfOrders(O); assert b;
    b, F_asProd := IsProductOfIdeals(O!!F); assert b;
    F_indexes := [Index(Order(I),I) : I in F_asProd];
    primes_above_p := AssociativeArray(); // <i, p> -> list of primes above p in O_asProd[i]
    primes_by_norm := []; // list of primes, sorted by norm.  Will be trimmed so that the orders of the elements do not decrease after quotienting by the already chosen generators
    orders_of_primes := []; // order in Pic(S) of the corresponding entry of primes_by_norm
    prime_lifts := []; // discrete log of each prime, as an element of P
    Psub := sub<P |>;
    // GOAL: fill in prime_list, prime_indexes, prime_lifts and all_of_order
    // We want the primes in prime_list to generate P, and to have order in P/Psub equal to their order in P.
    expand_factor_base := procedure(~q, ord_goal, curquo, ~primes_above_p, ~primes_by_norm, ~orders_of_primes, ~prime_lifts, ~Pgens)
        // subgroup of P generated by already chosen generators
        print "Expanding factor base", q, ord_goal, AbelianInvariants(Codomain(curquo)), #primes_above_p, #primes_by_norm, #Pgens;
        t0 := Cputime();
        Psub, _ := sub<P | Pgens>;
        stop := false;
        curquoExp := Exponent(Codomain(curquo));
        while true do
            // we will loop over prime powers q
            // and then we add primes of norm q to our list of primes
            while true do
                q +:= 1;
                b, p, k := IsPrimePower(q);
                if b then // q is a prime power
                    break;
                end if;
            end while;
            // if k = 1, we create a list of split primes above p.
            // this is used to create a list of primes of norm q for all powers of p.
            if k eq 1 then
                for i in [1..#O_asProd] do
                    OL := O_asProd[i];
                    L := NumberField(OL);
                    FL := F_asProd[i];
                    Lp := PrimeIdealsOverPrime(L, p);
                    if F_indexes[i] mod p eq 0 then
                        // Remove primes dividing the conductor
                        Lp := [I : I in Lp | One(OL) in I+FL];
                    // in the other case, we keep the last element, even though its lift is automatically in the span of the others, since it might have a better order
                    end if;
                    if #Lp gt 1 then
                        // Sort using the LMFDB label
                        keys := [<StringToInteger(c) : c in Split(LMFDBLabel(Lp[z]), ".")> cat <z> : z in [1..#Lp]];
                        Sort(~keys);
                        Lp := [Lp[key[#key]] : key in keys];
                    end if;
                    primes_above_p[<i,p>] := Lp;
                end for;
            end if;
            for i in [1..#O_asProd] do
                for prime in primes_above_p[<i,p>] do
                    // create a Oprime = \prod_j prime if i eq j else 1
                    // where Norm(Oprime) = q = p^k
                    if InertiaDegree(prime) eq k then
                        Oprime := Ideal(O, <(i eq j) select prime else 1*O_asProd[j] : j in [1..#O_asProd]>);
                        Sprime := (S!!Oprime meet S);
                        plift := Sprime@@pmap;
                        ord := Order(plift);
                        pproj := curquo(plift);
                        if PrimePart(ord, curquoExp) eq ord_goal and Order(pproj) eq ord_goal and not stop then
                            // we don't stop immediately since we still need to finish this value of q
                            Insert(~Pgens, 1, CoprimePart(ord, curquoExp) * plift);
                            stop := true;
                        end if;

                        Append(~primes_by_norm, Sprime);
                        Append(~orders_of_primes, ord);
                        Append(~prime_lifts, plift);
                    end if;
                end for;
            end for;
            if stop then
                break;
            end if;
        end while;
        print "Done in", Cputime() - t0, q, ord_goal, AbelianInvariants(Codomain(curquo)), #primes_above_p, #primes_by_norm, #Pgens;
    end procedure;
    use_factor_base := procedure(~found, gen_ord, curquo, ~primes_by_norm, ~orders_of_primes, ~prime_lifts, ~Pgens)
        print "Using factor base", gen_ord, #primes_by_norm, #Pgens;
        t0 := Cputime();
        curquoExp := Exponent(Codomain(curquo));
        found := false;
        for i in [1..#primes_by_norm] do
            if PrimePart(orders_of_primes[i], curquoExp) eq gen_ord and Order(curquo(prime_lifts[i])) eq gen_ord then
                found := true;
                Insert(~Pgens, 1, CoprimePart(orders_of_primes[i], curquoExp) * prime_lifts[i]);
                break;
            end if;
        end for;
        print "Done in", Cputime()-t0;
    end procedure;

    // We construct an initial factor base
    curquo := map<P -> P|x :-> x, y :-> y>;
    Pgens := [];
    q := 1;

    // Now choose new generators
    // AbelianBasis returns a generating set with orders equal to the abelian invariants of P
    invs := AbelianInvariants(P);
    for gen_num in [#invs..1 by -1] do
        gen_ord := invs[gen_num];
        found := false;
        use_factor_base(~found, gen_ord, curquo, ~primes_by_norm, ~orders_of_primes, ~prime_lifts, ~Pgens);
        if not found then
            expand_factor_base(~q, gen_ord, curquo, ~primes_above_p, ~primes_by_norm, ~orders_of_primes, ~prime_lifts, ~Pgens);
        end if;
        _, curquo := quo<P|Pgens>;
    end for;
    return Pgens;
end intrinsic;

intrinsic CanonicalPicGenerators(S::AlgEtQOrd) -> RngIntElt
{}
    A := Algebra(S);
    O := MaximalOrder(A);
    F := Conductor(S);
    P, pmap := PicardGroup(S);
    nfs:=[ Coefficients(DefiningPolynomial(K)) : K in Components(A) ];
    ind:=[1..#nfs];
    ParallelSort(~nfs, ~ind);
    b, O_asProd := IsProductOfOrders(O); assert b; assert #O_asProd eq #ind;
    O_asProd := [O_asProd[ind[i]] : i in [1..#ind]];
    b, F_asProd := IsProductOfIdeals(O!!F); assert b; assert #F_asProd eq #ind;
    F_asProd := [F_asProd[ind[i]] : i in [1..#ind]];
    F_indexes := [Index(Order(I),I) : I in F_asProd];
    primes_above_p := AssociativeArray();
    primes_by_norm := [];
    Pgens := [];
    Psub := sub<P|>;
    q := 1;
    while true do
        // we will loop over prime powers q
        // and then we add primes of norm q to our list of primes
        while true do
            q +:= 1;
            b, p, k := IsPrimePower(q);
            if b then // q is a prime power
                break;
            end if;
        end while;
        // if k = 1, we create a list of split primes above p.
        // this is used to create a list of primes of norm q for all powers of p.
        if k eq 1 then
            for i in [1..#O_asProd] do
                OL := O_asProd[i];
                L := NumberField(OL);
                FL := F_asProd[i];
                Lp := PrimeIdealsOverPrime(L, p);
                if F_indexes[i] mod p eq 0 then
                    // Remove primes dividing the conductor
                    Lp := [I : I in Lp | One(OL) in I+FL];
                // in the other case, we keep the last element, even though its lift is automatically in the span of the others, since it might have a better order
                end if;
                if #Lp gt 1 then
                    // Sort using the LMFDB label
                    keys := [<StringToInteger(c) : c in Split(LMFDBLabel(Lp[z]), ".")> cat <z> : z in [1..#Lp]];
                    Sort(~keys);
                    Lp := [Lp[key[#key]] : key in keys];
                end if;
                primes_above_p[<i, p>] := Lp;
            end for;
        end if;
        for i in [1..#O_asProd] do
            for prime in primes_above_p[<i,p>] do
                // create a Oprime = \prod_j prime if i eq j else 1
                // where Norm(Oprime) = q = p^k
                if InertiaDegree(prime) eq k then
                    Oprime := Ideal(O, <(i eq j) select prime else 1*O_asProd[j] : j in [1..#O_asProd]>);
                    Sprime := (S!!Oprime meet S);
                    plift := Sprime@@pmap;
                    if #sub<P|Pgens cat [plift]> gt #Psub then
                        Append(~Pgens, plift);
                        Psub := sub<P|Pgens>;
                        if #Psub eq #P then
                            return Pgens;
                        end if;
                    end if;
                end if;
            end for;
        end for;
    end while;
end intrinsic;

intrinsic remove_whitespace(X::MonStgElt) -> MonStgElt
{ Strips spaces and carraige returns from string; much faster than StripWhiteSpace. }
    return Join(Split(Join(Split(X," "),""),"\n"),"");
end intrinsic;

intrinsic sprint(X::.) -> MonStgElt
{ Sprints object X with spaces and carraige returns stripped. }
    if Type(X) eq Assoc then return Join(Sort([ $$(k) cat "=" cat $$(X[k]) : k in Keys(X)]),":"); end if;
    return remove_whitespace(Sprintf("%o",X));
end intrinsic;

intrinsic GensToBasis(S::AlgEtQOrd, gens::SeqEnum) -> SeqEnum
{Takes as input an order S in an etale algebra and a sequence gens of generators of Pic(S), and returns a basis of Pic(S) (aligning with the structure described by AbelianInvariants(Pic(S)))}
    P := PicardGroup(S);
    invs := AbelianInvariants(P);
    vprint User1: "Starting GensToBasis", Index(MaximalOrder(Algebra(S)), S), sprint(invs); t0:=Cputime();
    curquo := map<P -> P|x :-> x, y :-> y>;
    basis := [];
    orders := [Order(g) : g in gens];
    while #basis lt #invs do
        Psub := sub<P|basis>;
        _, curquo := quo<P|Psub>;
        orders := [Order(curquo(g)) : g in gens];
        looking_for := invs[#invs-#basis];
        // We can skip orders that are dominated by earlier orders
        lcms := [orders[1]];
        for i in [2..#orders] do
            Append(~lcms, Lcm(lcms[i-1], orders[i]));
        end for;
        relevant := [i : i in [1..#orders] | orders[i] gt 1 and (i eq 1 or lcms[i-1] mod orders[i] ne 0)];
        n := 1; // encode subset using bits
        while true do
            ss := IntegerToSequence(n, 2);
            ord := Lcm([orders[relevant[c]] : c in [1..#ss] | ss[c] eq 1]);
            if ord eq looking_for then
                b := &+[gens[relevant[c]] : c in [1..#ss] | ss[c] eq 1];
                // b has the right order in the projection, but we need to subtract off some combination of the previous generators to make it the right order in P itself
                // (ord * b) in Psub, since it's 0 in the quotient.  Morever, ord*b in ord*Psub, since ord divides the order of each of the generators of Psub.  Need to find this element so that we can subtract.
                if #basis gt 0 then
                    AbSub := AbelianGroup(invs[#invs-#basis+1..#invs]);
                    iso := hom<AbSub -> P | [<AbSub.j, basis[#basis+1-j]> : j in [1..#basis]]>;
                    y := Eltseq((ord*b) @@ iso);
                    assert &and[y[j] mod ord eq 0 : j in [1..#y]];
                    b -:= &+[(y[j] div ord) * basis[#basis+1-j] : j in [1..#basis]];
                    assert Order(b) eq ord;
                end if;
                Append(~basis, b);
                break;
            end if;
            n +:= 1;
        end while;
        vprint User1: "basis loop", Cputime() - t0, sprint(orders), looking_for, n; t0 := Cputime();
    end while;
    Reverse(~basis);
    assert [Order(b) : b in basis] eq invs and #sub<P|basis> eq #P;
    return basis;
end intrinsic;

intrinsic CanonicalPicBasis(ZFV::AlgEtQOrd) -> List
{Find an abelian basis for the Picard group of each overorder of ZFV using a deterministic method}
    vprint User1: "Starting OverOrders"; t0 := Cputime();
    oo := OverOrders(ZFV);
    vprint User1: "OverOrders finished", Cputime() - t0;
    oo := Remove(oo, Index(oo, ZFV)) cat [ZFV];
    assert oo[#oo] eq ZFV;
    vprint User1: "Starting PicardGroup"; t0 := Cputime();
    P0, pmap0 := PicardGroup(ZFV);
    vprint User1: "PicardGroup finished", Cputime() - t0; t0 := Cputime();
    ZFVgens := CanonicalPicGenerators(ZFV);
    vprint User1: "CanonicalPicGenerators finished", Cputime() - t0; t0:=Cputime();
    igens := [pmap0(P0.i) : i in [1..Ngens(P0)]];
    vprint User1: "igens finished", Cputime() - t0;
    cangens := [* *];
    for S in oo[1..#oo-1] do
        vprint User1: "Starting PicardGroup", Index(oo, S); t0:=Cputime();
        P, pmap := PicardGroup(S);
        vprint User1: "PicardGroup finished", Cputime() - t0; t0:=Cputime();
        P0Pmap := hom<P0 -> P | [<P0.i, (S!!igens[i]) @@ pmap> : i in [1..Ngens(P0)]]>;
        Sgens := [P0Pmap(g) : g in ZFVgens];
        vprint User1: "Sgens finished", Cputime() - t0; t0:=Cputime();
        Append(~cangens, Sgens);
    end for;
    Append(~cangens, ZFVgens);
    return [* GensToBasis(oo[i], cangens[i]) : i in [1..#oo] *];
end intrinsic;

intrinsic Random(G::GrpAuto : word_len:=40) -> GrpAutoElt
{}
    gens := [<g, Order(g)> : g in Generators(G)];
    gens := [pair : pair in gens | pair[2] ne 1];
    r := Identity(G);
    for i in [1..word_len] do
        j := Random(1,#gens);
        k := Random(0,gens[j][2]-1);
        r *:= gens[j][1]^k;
    end for;
    return r;
end intrinsic;

intrinsic TestLMFDBGenerators(S::AlgEtQOrd : ntries:=4)
{The algorithm for computing the Picard group of S uses randomness; here we check that two different runs of PicardGroup(S) yield the same choice of generators out of LMFDBGenerators}
    t0:=Cputime();
    P1, pmap1 := PicardGroup(S);
    if #P1 le 2 then
        // There is actually no choice in this case
        printf "Pic(S) has order %o, so generators are canonical\n", #P1;
        return;
    end if;
    printf "Finished computing Picard group %o in %os\n", AbelianInvariants(P1), Cputime()-t0; t0:=Cputime();
    G1 := CanonicalPicBasis(S);
    printf "Finished computing generators in %o\n", Cputime()-t0; t0:=Cputime();
    A := AutomorphismGroup(P1);
    printf "Finished computing automorphism group in %o\n", Cputime()-t0; t0:=Cputime();
    for tries in [1..ntries] do
        a := Random(A);
        pmap2 := a * pmap1;
        S`PicardGroup := <P1, pmap2>;
        G2 := LMFDBGenerators(S);
        G12 := [(G2[i] @ pmap2 @@ pmap1) : i in [1..#G2]];
        assert G12 eq G1;
        printf "Test %o successful in %o: same generators chosen", tries, Cputime()-t0; t0 := Cputime();
    end for;
    print "Testing complete";
end intrinsic;

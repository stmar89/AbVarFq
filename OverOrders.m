freeze;

/////////////////////////////////////////////////////
// OverOrders for Etale Q algebras
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
// and Edgar Costa, MIT
/////////////////////////////////////////////////////
declare attributes AlgAssVOrd : MinimalOverOrders;
declare attributes AlgAssVOrd : OverOrders;

intrinsic pMaximalOrder(O::AlgAssVOrd, p::RngIntElt) -> AlgAssVOrd
{given O, retuns the maximal p over order}
  if (Abs(Integers() ! Discriminant(O)) mod p^2) ne 0 then
    return O;
  end if;

  OO := O;
  // Theorem 6.1.3 Cohen
  while true do
    I := ArithmeticRadical(OO, BaseRing(OO)*p);
    OO := MultiplicatorRing(I);
    if OO eq Order(I) then
      return OO;
    end if;
  end while;
end intrinsic;

intrinsic ResidueField(P::AlgAssVOrdIdl) -> FldFin, Map
{ given P a prime of S, returns a finite field F isomorphic to S/P and a surjection (with inverse) S->F.}
	assert2 IsPrime(P);
	S := Order(P);
	Q,q := ResidueRing(S,P); //q:S->S/P
	size := #Q;
	F := FiniteField(size);
	min_poly := PolynomialRing(Integers())!DefiningPolynomial(F);
	//the following loop is naive
	for y in Q do
		if q(Evaluate(min_poly,y@@q)) eq Zero(Q) then
			prim_elt_inQ := y;
			prim_elt_inA := y@@q;
			break y;
		end if;
	end for;
	//now I need to build  the map
	G,gGF := AdditiveGroup(F); //g:G->F
	hGQ := iso<G->Q | [q(prim_elt_inA^i) : i in [0..Degree(min_poly)-1]]>;
	hQG := Inverse(hGQ);
	map := q*hQG*gGF;
	return F, map;
end intrinsic;

intrinsic QuotientVS(I::Any, J::Any, P::AlgAssVOrdIdl, K::FldFin, k::Map) -> ModFld, Map
{
 let I, J, P be fractional R-ideals such that:
 - P is prime with residue field K;
 - k the map
 - J in I and I/J is a vector space over R/P, say of dimension d;
 the function returns the KModule K^d=V and the natural surjection I->V (with pre-image)}
    require {Type(I),Type(J)} subset {AlgAssVOrd,AlgAssVOrdIdl} : "I and J must be either orders (AlgAssVOrd) or ideals (AlgAssVOrdIdl)";
    assert2 P*(ideal<Order(P)|ZBasis(I)>) subset (ideal<Order(P)|ZBasis(J)>);
	S := Order(P);
    assert2 S subset MultiplicatorRing(I);
    assert2 S subset MultiplicatorRing(J);
	A := Algebra(S);
	d := Ilog(#K,Integers() ! (Index(J)/Index(I))); // d = dim(I/J) over (S/P)
	V := KModule(K,d);
	//need to find a basis of I/J over R/P.
	zbI := ZBasis(I);
	N := #zbI;
	F := FreeAbelianGroup(N);
	relJ := [F ! cc : cc in Coordinates(ZBasis(J),zbI)];
    rel:=relJ;
	mFI := map<F->A| x:->&+[Eltseq(x)[i]*zbI[i] : i in [1..N]]>;
	mIF := map<A->F| x:-> F ! Eltseq(Coordinates([x],zbI)[1])>;
	Q,q := quo<F|rel>; //q:F->Q. Q is an "abstract" abelian group isomorphic to I/J.
	bas := [];
	for i in [1..d] do
    //for each iteration of the loop we mod-out from I the S-ideal generated by J and the already found elements of the basis of I/J over S/P
		elt_F := (Q.1@@q);
		elt_I := mFI(elt_F);
		Append(~bas,elt_I);
        rel_i:=[mIF(bb) : bb in ZBasis(ideal<S|elt_I>)];
		rel := rel cat rel_i;
		Q, q := quo<F|rel>; //q:F->Q
	end for;
	assert IsTrivial(Q);
    //function mIV using HNF: bas[i]*S+J eq I. exploit this on ZBasis level to find the S-coordinates of ZBasis(I) wrt bas[i]'s 
    zbJ:=ZBasis(J);
    zbS:=ZBasis(S);
    gens:=&cat[[ b*z: z in zbS ] : b in bas];
    mat:=Matrix(gens cat zbJ);
    den:=Denominator(mat);
    dmat:=ChangeRing(den*mat,Integers());
    H,Tr:=HermiteForm(dmat);//Tr*M eq H
    HI,TrI:=HermiteForm(ChangeRing(den*Matrix(zbI),Integers()));
    TrI:=ChangeRing(TrI,Rationals());
    Tr1:=ChangeRing(Matrix(Rows(Tr)[1..#zbI]),Rationals());
    C:=TrI^-1*Tr1;
    new_coords_zbI:=[];
    for k in [1..#zbI] do
        zbIk:=[];
        for i in [0..d-1] do    
            coord_i:=&+[C[k,i*N+j]*zbS[j] : j in [1..#zbS]];
            Append(~zbIk,coord_i);
        end for;
        Append(~new_coords_zbI,zbIk);
    end for;
    mIV:=function(x)
        xinI:=Coordinates([x],zbI)[1];
        coords_inS:=[ &+[xinI[i]*new_coords_zbI[i][k]: i in [1..#zbI]]  : k in [1..d]];
        coords_inK:=[k(c) : c in coords_inS];
        return &+[coords_inK[i]*V.i : i in [1..d]];
    end function;
	mVI := function(y)
		return &+[ bas[j]*(Eltseq(y)[j]@@k) : j in [1..d] ];
    end function;
    return V, map<A->V | x:->mIV(x), y:->mVI(y) >;
end intrinsic;


intrinsic MinimalOverOrders(R::AlgAssVOrd : singular_primes := [], orders := {@ @}) -> SetIndx[AlgAssVOrd]
{ returns the minimal over orders of R given the singular primes of R 
  Based on "On the computations of overorders" by TommyHofmann and Carlo Sircana}
if not assigned R`MinimalOverOrders then
    min_oo := { };
    if not IsMaximal(R) then
      zbR := ZBasis(R);
      if singular_primes ne [] then
        pp := [(R!P) meet (OneIdeal(R)) : P in singular_primes];
        pp := Setseq(Seqset(pp)); //remove duplicates
        pp := [P : P in pp | Index(P, P*P) ne Index(R,P)]; //only the sing ones
        assert2 SequenceToSet(pp) eq SequenceToSet(PrimesAbove(Conductor(R)));
      else
        pp := PrimesAbove(Conductor(R));
      end if;
      for P in pp do
        pot_min_oo := {@ @}; // will contain all potential minimal over-orders.
        pot_min_oo_2 := {@ @}; // will contain all potential minimal over-orders of dimension ge 2
        F, f := ResidueField(P);
        T := MultiplicatorRing(P);
        V,mTV := QuotientVS(T, R, P, F, f);
        assert2 forall{ v : v in Basis(V) | mTV((v@@mTV)^2) in V };
        assert2 forall{ v : v in Basis(V) | mTV((v@@mTV)) eq v };
        assert2 forall{ t : t in ZBasis(T) | t-((mTV(t))@@mTV) in R };
        d := Dimension(V);
        //see Proposition 5.3 of Tommy's paper
        if d eq 1 then
          Include(~min_oo, T);
        else
          q:=#F; //need to use q! not the characterstic of F!
          qpow:=hom<V->V | [mTV((v@@mTV)^q) : v in Basis(V)]>;
          eigen_vals:=[e[1] : e in Setseq(Eigenvalues(Matrix(qpow)))];
          eigen_spaces:=[Kernel(hom<V->V | [qpow(v)-e*v : v in Basis(V)]>)
                               : e in eigen_vals]; //in this way there are naturally embedded in V
          subs_1:=[ W: W in &cat[Submodules(E) : E in eigen_spaces] | Dimension(W) eq 1];
          for W in subs_1 do //dim eq 1
            wT:=W.1@@mTV;
            if q eq 2 or mTV(wT^2) in W then
            //doing this square directly on the finite field level would probably be faster.
            //for p eq 2 being a subspace of the eigenspace garantuees that it is mult closed
                S:=Order([wT] cat zbR);
                Include(~pot_min_oo,S);
                Include(~min_oo,S);//necessarly minimal
            end if;
          end for;
          dims := PrimesUpTo(d+1); //the plus one is to prevent issues when d=2.
          subs_2 := Submodules(V : CodimensionLimit := d-2); //we exclude dim 0 and 1
          subs_2 := [W : W in subs_2 | Dimension(W)+1 in dims];
          //only subs of dim a prime number
          //the +1 comes from using (P:P)/R instead of (P:P)/P, see Remark 5.4
          for W in subs_2 do //dim at least 2
            S := Order([(w@@mTV) : w in Basis(W)] cat zbR);
            Include(~pot_min_oo,S);
            Include(~pot_min_oo_2,S);
          end for;
          //we remove non-minimals
          for S in pot_min_oo_2 do
            if not exists {T : T in pot_min_oo | S ne T and T subset S} then
              Include(~min_oo, S);
            end if;
          end for;
        end if;
      end for;
    end if;
    R`MinimalOverOrders := {@ @};
    for S in min_oo do
      i := Index(orders, S);
      if i eq 0 then
        Include(~R`MinimalOverOrders, S);
      else
        Include(~R`MinimalOverOrders, orders[i]);
      end if;
    end for;
  end if;
  return R`MinimalOverOrders;
end intrinsic;


intrinsic FindOverOrders_Minimal(R::AlgAssVOrd) -> SetIndx[AlgAssVOrd]
{ Given an order R returns all the over orders by a recursive search of the minimal overordes.
  Based on "On the computations of overorders" by TommyHofmann and Carlo Sircana}
  A := Algebra(R);
  require IsFiniteEtale(A): "the algebra of definition must be finite and etale over Q";
  singular_primes := PrimesAbove(MaximalOrder(A)!Conductor(R));
  //singular_primes := [];
  queue := {@ R @};
  done := {@  @};
  output := {@ @};
  while #queue gt 0 do
    output join:=  queue;
    done join:= queue;
    for elt in queue do
      output join:= MinimalOverOrders(elt : singular_primes := singular_primes, orders := output);
    end for;
    queue := output diff done;
  end while;
  return output;
end intrinsic;


intrinsic FindOverOrders(E::AlgAssVOrd: alg := "minimal", populateoo_in_oo := false) -> SetIndx[AlgAssVOrd]
{returns all the overorders of E, and populates }
  require alg in ["minimal", "naive"]: "only naive and minimal options are supported";
  if not assigned E`OverOrders then
    if alg eq "minimal" then
      E`OverOrders := FindOverOrders_Minimal(E);
      //for S in E`MinimalOverOrders do
      //  _ := FindOverOrders(S: alg := "minimal");
      //end for;
    elif alg eq "naive" then
      E`OverOrders := FindOverOrders_Naive(E);
    end if;
  end if;

  // there might be a better way to do this
  // like looping over MaximalUnderOrders
  if populateoo_in_oo then
    for i in [1..#E`OverOrders] do
      S := E`OverOrders[i];
      if not assigned S`OverOrders then
        S`OverOrders := {@ T : T in E`OverOrders | S subset T @};
      end if;
    end for;
  end if;
  return E`OverOrders;
end intrinsic;


// what follows is OLD
//
intrinsic FindOverOrders(E::AlgAssVOrd, O::AlgAssVOrd) -> SetIndx[AlgAssVOrd]
{given E subset O, returns the sequence of orders between E and O}
	require IsFiniteEtale(Algebra(E)): "the algebra of definition must be finite and etale over Q";
	require E subset O : "the first argument must be a subset of the second";
  //modified by Edgar
  return {@ S: S in FindOverOrders(E) | S subset O @};
end intrinsic;

intrinsic FindOverOrders_Naive(E::AlgAssVOrd) -> SetIndx[AlgAssVOrd]
{returns all the overorders of E}
  A := Algebra(E);
  require IsFiniteEtale(A): "the algebra of definition must be finite and etale over Q";
  O := MaximalOrder(A);
  if IsMaximal(E) then
    return [E];
  end if;
  return FindOverOrders_Naive(E,O);
end intrinsic;

intrinsic FindOverOrders_Naive(E::AlgAssVOrd, O::AlgAssVOrd) -> SetIndx[AlgAssVOrd]
{given E subset O, returns the sequence of orders between E and O}
//15/02/2018 we add the LowIndexProcess
	require IsFiniteEtale(Algebra(E)): "the algebra of definition must be finite and etale over Q";
	require E subset O : "the first argument must be a subset of the second";
  F := FreeAbelianGroup(Degree(O));
  E_ZBasis := ZBasis(E);
  O_ZBasis := ZBasis(O);
  rel := [F ! Eltseq(x) : x in Coordinates(E_ZBasis, ZBasis(O))];
  Q,q := quo<F|rel>; //q:F->Q quotient map
  FP,f := FPGroup(Q); //f:FP->Q isomorphism
  N := #FP;
  subg := LowIndexProcess(FP,<1,N>);
  seqOO := {@ @};
  while not IsEmpty(subg) do
    H := ExtractGroup(subg);
    NextSubgroup(~subg);
    geninF := [(f(FP ! x))@@q : x in Generators(H)];
    coeff := [Eltseq(x) : x in geninF];
    S := Order([&+[O_ZBasis[i]*x[i] : i in [1..Degree(Algebra(O))]] : x in coeff] cat E_ZBasis);
    if S ne O then
      Include(~seqOO, S);
    end if;
  end while;
  Include(~seqOO,O); //in this way O is the last of the list
  assert E in seqOO and O in seqOO;
  return seqOO;
end intrinsic;


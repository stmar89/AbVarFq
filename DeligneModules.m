/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Abelian varieties and Isogeny classes
// Stefano Marseglia, Utrecht University, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
// with the help of Edgar Costa
/////////////////////////////////////////////////////

declare verbose AbelianVarieties, 1;

/////////////////////////////////////////////////////
// New Type AbelianVarietyFq
/////////////////////////////////////////////////////

declare type AbelianVarietyFq;
declare attributes AbelianVarietyFq : DeligneModule; //of type AlgEtQMod

intrinsic Print(I::AbelianVarietyFq)
{ print the abelian variety }
    printf "Abelian variety over FF_%o",FiniteField(I);
end intrinsic;

/////////////////////////////////////////////////////
// Creation functions of AbelianVarietyFq
/////////////////////////////////////////////////////

intrinsic AbelianVariety( AVh::IsogenyClassFq , I::AlgEtQIdl )->AbelianVarietyFq
{Returns the abelian variety defined by a fractional ideal I of the Z[F,V] order of the isogeny class AV(h), where h is the characteristic polynomial of the Frobenius. The isogeny class needs to be ordinary or CentelegheStix.} 
    require IsSquarefree(AVh) and (IsOrdinary(AVh) or IsCentelegheStix(AVh)) : "The input does not define an abelian variety in the isogeny class.";
    assert Algebra(R) eq UA;
    R,map:=ZFVOrder(AVh); // map: Algebra(R) -> UA the identity map
    require R eq Order(I):"The fractional ideal is not defined over the order Z[F,V] of the given isogeny class.";
    UA:=UniverseAlgebra(AVh);
    AV:=New(AbelianVarietyFq);
    AV`IsogenyClass:=AVh;
    AV`DeligneModule:=ModuleFromDirectSum(R,map,<I,map>);
    return AV;
end intrinsic;

intrinsic AbelianVariety( AVh::IsogenyClassFq , seq::SeqEnum[AlgEtQIdl] )-> AbelianVarietyFq
{Returns the abelian variety defined by a direct sum of s fractional ideals of the Z[F,V] order of the isogeny class AV(g^s), where g is the miniml polynomial of the Frobenius. The isogeny class needs to be ordinary or CentelegheStix.} 
    require IsPurePower(AVh) and (IsOrdinary(AVh) or IsCentelegheStix(AVh)) : "The input does not define an abelian variety in the isogeny class.";
    R,delta:=ZFVOrder(AVh);
    s:=#seq;
    require forall{ I : I in seq | R eq Order(I) } : "the sequence of fractional ideals does not define an abelin variety in the given isogeny class";
    UA:=UniverseAlgebra(AVh);
    E:=Algebra(R);
    AV:=New(AbelianVarietyFq);
    AV`IsogenyClass:=AVh;
    ort:=OrthogonalIdempotents(UA);
    DM:=[];
    require #ort eq s : "Not enough ideals to generate an abelian variety in this isogeny class.";
    for i in [1..s] do
        I:=seq[i];
        map:=Hom(E,UA,[map(z)*ort[i]:z in Basis(E)]); // embedding of Ag->Ag^s into the ith component
        Append(~DM,<I,map>);
    end for;    
    AV`DeligneModule:=ModuleFromDirectSum(R,delta,DM);
    return AV;
end intrinsic;

intrinsic AbelianVariety( AVh::IsogenyClassFq , seq::SeqEnum[AlgEtQElt] )-> AbelianVarietyFq
{Returns the abelian variety defined defined by the module generated by the elements in seq. The isogeny class needs to be ordinary or CentelegheStix.}
    require IsOrdinary(AVh) or IsCentelegheStix(AVh) : "The input does not define an abelian variety in the isogeny class.";
    R,delta:=ZFVOrder(AVh);
    UA:=UniverseAlgebra(AVh);
    require forall{ g : g in seq | Parent(g) eq UA } : " the elements are not in the UniverseAlgebra(A)";
    AV:=New(AbelianVarietyFq);
    AV`IsogenyClass:=AVh;
    is_lattice:=Rank(Matrix(seq)) eq Dimension(UA);
    require is_lattice : "the elements in seq do not generate a lattice in the UniverseAlgebra(A) ";
    AV`DeligneModule:=Module(R,delta,seq);
    return AV;
end intrinsic;

intrinsic AbelianVariety(AVh::IsogenyClassFq,seq::SeqEnum[Tup])->AbelianVarietyFq
{Given an isogeny class and sequence of pairs  <J_i,v_i> returns the abelin variety in the given isogeny class defined by the Deligne Module J_1v_1+...+J_sv_s. The isogeny class needs to be ordinary or CentelegheStix.}
    require IsPurePower(AVh) and IsOrdinary(AVh) or IsCentelegheStix(Avh) : "The input does not define an abelian variety in the isogeny class.";
    R,delta:=ZFVOrder(AVh);
    g:=DefiningPolynomial(Algebra(R));
    UA:=UniverseAlgebra(AVh);
    s:=#seq;
    require forall{ J : J in seq | R eq Order(J[1]) and Parent(J[2]) eq UA } : "the sequence of fractional ideals does not define an abelin variety in the given isogeny class";
    AV:=New(AbelianVarietyFq);
    AV`IsogenyClass:=AVh;
    AV`DeligneModule:=Module(R,delta,seq);
    return AV;
end intrinsic;

/////////////////////////////////////////////////////
// Access functions for AbelianVarietyFq
/////////////////////////////////////////////////////

intrinsic DeligneModule(A :: AbelianVarietyFq)->AlgEtQMod
{Returns the DeligneModule defining the variety A.}
    return A`DeligneModule;
end intrinsic;

/////////////////////////////////////////////////////
// Equality testing for AbelianVarietyFq
/////////////////////////////////////////////////////

intrinsic 'eq'( A1 :: AbelianVarietyFq , A2 :: AbelianVarietyFq ) -> BoolElt
{Checks if two abelin varieties are equal, using the appropriate categorical description.}
    I:=IsogenyClass(A1);
    if I eq IsogenyClass(A2) then
        if IsOrdinary(I) or IsCentelegheStix(I) then
            return DeligneModule(A1) eq DeligneModule(A2);
        elif IsSquarefree(I) then
            error "TODO";
        else
            error "not implemented yet";
        end if;
    else
        vprintf AbelianVarieties : "eq : the abelian varities are not in the same isogeny class \n";
        return false;
    end if;
end intrinsic;

/* TESTS
 
    AttachSpec("~/packages_github/AbVarFq/packages.spec");
    _<x>:=PolynomialRing(Integers());
    f:=x^6-x^5+2*x^4-2*x^3+4*x^2-4*x+8;
    time IsogenyClass(f);
    time ZFVOrder(IsogenyClass(f));
    time pRank(IsogenyClass(f));
    time pRank(IsogenyClass(f : Check:=false ));
    IsOrdinary(f);
    
    AVf:=IsogenyClass(f);
    IsOrdinary(AVf);
    _:=ComputeIsomorphismClasses(AVf);
    time #ComputeIsomorphismClasses(AVf);
    for A,B in ComputeIsomorphismClasses(AVf) do t,s:=IsIsomorphic(A,B); end for;

    f:=x^6-x^5+2*x^4-2*x^3+4*x^2-4*x+8;
    time AVf:=IsogenyClass(f^3 );
    time AVf:=IsogenyClass(f^3 : Check:=false );
    FrobeniusEndomorphism(AVf);
    iso:=ComputeIsomorphismClasses(AVf);
    time #ComputeIsomorphismClasses(AVf); //it should be 0
    for A in iso do
        FrobeniusEndomorphism(A);
    end for;
    for A,B in iso do 
        t,s:=IsIsomorphic(A,B);
    end for;

    f:=x^6-x^5+2*x^4-2*x^3+4*x^2-4*x+8;
    h:=x^2-x+2;
    AVf:=IsogenyClass(h*f^2);
    iso:=ComputeIsomorphismClasses(AVf); //this should give an error
    ZFV:=ZFVOrder(AVf);


*/

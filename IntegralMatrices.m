freeze;
/////////////////////////////////////////////////////
// Stefano Marseglia, Stockholm University, stefanom@math.su.se, stefano.marseglia89@gmail.com
/////////////////////////////////////////////////////
/* ChangeLog
version 0.1->0.2: added intrinsic MatrixToIdeal( M::AlgMatElt )-> AlgAssVOrdIdl
version 0.2->0.3: cleaned the commented code, and randomQ which I was not using
		  added intrinsic RepresentativesZConjugates
		  sent to Eamonn for incorporation
*/
/*
List of functions:

intrinsic IdealToMatrix( I::AlgAssVOrdIdl )->AlgMatElt
intrinsic MatrixToIdeal( A::AlgAss,M::AlgMatElt )-> AlgAssVOrdIdl
intrinsic IsZConjugate( M1::AlgMatElt , M2:: AlgMatElt) -> BoolElt
intrinsic RepresentativesZConjugate( f::RngUPolElt ) -> Seq

*/

intrinsic IdealToMatrix( I::AlgAssVOrdIdl )->AlgMatElt
{given an ideal of an order in an (Ã©tale) algebra A=Q[x]/f1 x ...x Q[x]/fr, let a:=(x mod f1,..,x mod fr), return the integral matrix corresponding to the map "*a":I->I. Note that this matrix depends on the choice of a ZBasis of I and hence is uniquely defined only up to conjugation in Z}
    bas:=ZBasis(I);
    a:=PrimitiveElement(Algebra(I));
    M:=Transpose(Matrix(Integers(),Coordinates([a*x : x in bas],bas)));
    return M;
end intrinsic;

intrinsic MatrixToIdeal( A::AlgAss,M::AlgMatElt )-> AlgAssVOrdIdl
{Given an associative algebra A generated by a (squarefree) polynomial f and an integral matrix M with charactersitic polynomial f, it returns a sequence of elements of A that generated a fractional ideal of the euqation order of f which corresponds to the matrix M}
     require BaseRing(M) eq Integers() : "the matrix must be defined over the intergers";
     f:=CharacteristicPolynomial(M);
     N:=Degree(f);
     
     require f eq DefiningPolynomial(A): "the algebra is not generated by the minimal polynomial of the matri";
     require IsSquarefree(MinimalPolynomial(M)) : "the matrix must be semisimple";
    
     rows:=[];
     for l in A`NumberFields do
        L:=l[1];
        LtoA:=l[2];
        aL:=PrimitiveElement(L);
        bas:=Basis(NullSpace(ChangeRing(M,L)-DiagonalMatrix([aL : i in [1..N]])));
        for v in bas do
            Append(~rows,[LtoA(v[i]) : i in [1..N]]);
        end for;
     end for;
     G:=Matrix(A,rows);
     Gt:=Transpose(G);
     Ws:=[ &+Eltseq(w) : w in Rows(Gt) ];
     return Ws;
end intrinsic;

intrinsic IsZConjugate( M1::AlgMatElt , M2:: AlgMatElt) -> BoolElt
{given two integral matrices M1 and M2 with squarefree charactersitic polynomial returns wheter the matrices are conjugates over the integers and if this is the case, it returns also a matrix U such that U^-1*M1*U equals M2}
     f:=CharacteristicPolynomial(M1);
     if not CharacteristicPolynomial(M2) eq f then 
        printf "the characteristic polynomials are not the same\n";
        return false,_;
     else 
     	require IsSquarefree(f) : "the characteristic polynomial of the inputs must be square-free";
        A:=AssociativeAlgebra(f);
        R:=EquationOrder(A);
	bas1:=MatrixToIdeal(A,M1);
	bas2:=MatrixToIdeal(A,M2);
        id1:=ideal<R|bas1>;
        id2:=ideal<R|bas2>;
        test,elt:=IsIsomorphic2(id1,id2);
	if test then
		U:=Transpose(Matrix(Integers(),[Eltseq(s) :s in Coordinates([elt*b : b in bas2],bas1)]));
		assert (U^-1*M1*U) eq M2;
		return test,U;
	else
		return false,_;
	end if;
     end if;
end intrinsic;


intrinsic RepresentativesZConjugate( f::RngUPolElt ) -> Seq
{given a monic square-free polynomial f with integer coefficients it returns a set of representatives of the Z-conjugacy classes of integral matrices with characteristic (and and hence also minimal) polynomial f }
	require BaseRing(f) eq Integers() : "the polynomial doesn't have integer coefficients";
	require IsSquarefree(f) : "the polynomial is not squarefree";
	require IsMonic(f) : "the polynomial is not monic";

	A:=AssociativeAlgebra(f);
	E:=EquationOrder(A);
	icm:=ICM(E);
	reps:=[ IdealToMatrix(I) : I in icm ];
	return reps;
end intrinsic;

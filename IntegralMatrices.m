freeze;

/////////////////////////////////////////////////////
// Abelian varieties with squarefree polynomial, polarizations for the ordinary case and automorphisms
// Stefano Marseglia, Utrecht University, s.marseglia@uu.nl
// http://www.staff.science.uu.nl/~marse004/
/////////////////////////////////////////////////////

/* LIST of functions:
intrinsic IdealToMatrix( I::AlgAssVOrdIdl )->AlgMatElt
intrinsic MatrixToIdeal( A::AlgAss,M::AlgMatElt )-> AlgAssVOrdIdl
intrinsic IsZConjugate( M1::AlgMatElt , M2:: AlgMatElt) -> BoolElt
intrinsic RepresentativesZConjugate( f::RngUPolElt ) -> Seq
*/

intrinsic IdealToMatrix( I::AlgAssVOrdIdl )->AlgMatElt
{given an ideal of an order in an (Ã©tale) algebra A=Q[x]/f1 x ...x Q[x]/fr, let a:=(x mod f1,..,x mod fr), return the integral matrix corresponding to the map "*a":I->I. Note that this matrix depends on the choice of a ZBasis of I and hence is uniquely defined only up to conjugation in Z}
	bas:=ZBasis(I);
	a:=PrimitiveElement(Algebra(I));
	M:=Transpose(Matrix(Integers(),Coordinates([a*x : x in bas],bas)));
	return M;
end intrinsic;

intrinsic MatrixToIdeal( A::AlgAss,M::AlgMatElt )-> AlgAssVOrdIdl
{Given an associative algebra A generated by a (squarefree) polynomial f and an integral matrix M with charactersitic polynomial f, it returns a sequence of elements of A that generated a fractional ideal of the euqation order of f which corresponds to the matrix M}
	require BaseRing(M) eq Integers() : "the matrix must be defined over the intergers";
	f:=CharacteristicPolynomial(M);
	N:=Degree(f);

	require f eq DefiningPolynomial(A): "the algebra is not generated by the minimal polynomial of the matri";
	require IsSquarefree(MinimalPolynomial(M)) : "the matrix must be semisimple";

	rows:=[];
	for l in A`NumberFields do
	L:=l[1];
	LtoA:=l[2];
	aL:=PrimitiveElement(L);
	bas:=Basis(NullSpace(ChangeRing(M,L)-DiagonalMatrix([aL : i in [1..N]])));
	for v in bas do
	    Append(~rows,[LtoA(v[i]) : i in [1..N]]);
	end for;
	end for;
	G:=Matrix(A,rows);
	Gt:=Transpose(G);
	Ws:=[ &+Eltseq(w) : w in Rows(Gt) ];
	return Ws;
end intrinsic;

intrinsic IsZConjugate( M1::AlgMatElt , M2:: AlgMatElt) -> BoolElt
{given two integral matrices M1 and M2 with squarefree charactersitic polynomial returns wheter the matrices are conjugates over the integers and if this is the case, it returns also a matrix U such that U^-1*M1*U equals M2}
	f:=CharacteristicPolynomial(M1);
	if not CharacteristicPolynomial(M2) eq f then 
		printf "the characteristic polynomials are not the same\n";
		return false,_;
	else 
		require IsSquarefree(f) : "the characteristic polynomial of the inputs must be square-free";
		A:=AssociativeAlgebra(f);
		R:=EquationOrder(A);
		bas1:=MatrixToIdeal(A,M1);
		bas2:=MatrixToIdeal(A,M2);
		id1:=ideal<R|bas1>;
		id2:=ideal<R|bas2>;
		test,elt:=IsIsomorphic2(id1,id2);
		if test then
			U:=Transpose(Matrix(Integers(),[Eltseq(s) :s in Coordinates([elt*b : b in bas2],bas1)]));
			assert (U^-1*M1*U) eq M2;
			return test,U;
		else
			return false,_;
		end if;
	end if;
end intrinsic;


intrinsic RepresentativesZConjugate( f::RngUPolElt ) -> Seq
{given a monic square-free polynomial f with integer coefficients it returns a set of representatives of the Z-conjugacy classes of integral matrices with characteristic (and and hence also minimal) polynomial f }
	require BaseRing(f) eq Integers() : "the polynomial doesn't have integer coefficients";
	require IsSquarefree(f) : "the polynomial is not squarefree";
	require IsMonic(f) : "the polynomial is not monic";

	A:=AssociativeAlgebra(f);
	E:=EquationOrder(A);
	icm:=ICM(E);
	reps:=[ IdealToMatrix(I) : I in icm ];
	return reps;
end intrinsic;

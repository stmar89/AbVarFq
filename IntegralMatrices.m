/* vim: set syntax=magma :*/

freeze;

/////////////////////////////////////////////////////
// Stefano Marseglia, stefano.marseglia89@gmail.com
// https://stmar89.github.io/index.html
// 
// Distributed under the terms of the GNU Lesser General Public License (L-GPL)
//      http://www.gnu.org/licenses/
// 
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 3.0 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
// 
// Copyright 2023, S. Marseglia
/////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
// Z-conjugacy test for integral matrices with square-free characteristic polynomial
///////////////////////////////////////////////////////////////////////////////////

intrinsic IdealToMatrix( I::AlgAssVOrdIdl )->AlgMatElt
{given an ideal of an order in an (Ã©tale) algebra A=Q[x]/f1 x ...x Q[x]/fr, let a:=(x mod f1,..,x mod fr), return the integral matrix corresponding to the map "*a":I->I. Note that this matrix depends on the choice of a ZBasis of I and hence is uniquely defined only up to conjugation in Z}
	bas:=ZBasis(I);
	a:=PrimitiveElement(Algebra(I));
	M:=Transpose(Matrix(Integers(),Coordinates([a*x : x in bas],bas)));
	return M;
end intrinsic;

intrinsic MatrixToIdeal( A::AlgAss,M::AlgMatElt )-> AlgAssVOrdIdl
{Given an associative algebra A generated by a (squarefree) polynomial f and an integral matrix M with charactersitic polynomial f, it returns a sequence of elements of A that generated a fractional ideal of the euqation order of f which corresponds to the matrix M}
	require BaseRing(M) eq Integers() : "the matrix must be defined over the intergers";
	f:=CharacteristicPolynomial(M);
	N:=Degree(f);

	require f eq DefiningPolynomial(A): "the algebra is not generated by the minimal polynomial of the matri";
	require IsSquarefree(MinimalPolynomial(M)) : "the matrix must be semisimple";

	rows:=[];
	for l in A`NumberFields do
	L:=l[1];
	LtoA:=l[2];
	aL:=PrimitiveElement(L);
	bas:=Basis(NullSpace(ChangeRing(M,L)-DiagonalMatrix([aL : i in [1..N]])));
	for v in bas do
	    Append(~rows,[LtoA(v[i]) : i in [1..N]]);
	end for;
	end for;
	G:=Matrix(A,rows);
	Gt:=Transpose(G);
	Ws:=[ &+Eltseq(w) : w in Rows(Gt) ];
	return Ws;
end intrinsic;

intrinsic IsZConjugate( M1::AlgMatElt , M2:: AlgMatElt : GRH:=true ) -> BoolElt
{
    Given two integral matrices M1 and M2 with squarefree charactersitic polynomial returns wheter the matrices are conjugates over the integers and if this is the case, it returns also a matrix U such that U^-1*M1*U equals M2.
    The GRH optional argument sets the method bound that will be used in the isomorphism test. The default value is "true".
}
	f:=CharacteristicPolynomial(M1);
	if not CharacteristicPolynomial(M2) eq f then 
		printf "the characteristic polynomials are not the same\n";
		return false,_;
	else 
		require IsSquarefree(f) : "the characteristic polynomial of the inputs must be square-free";
		A:=AssociativeAlgebra(f);
		R:=EquationOrder(A);
		bas1:=MatrixToIdeal(A,M1);
		bas2:=MatrixToIdeal(A,M2);
		id1:=ideal<R|bas1>;
		id2:=ideal<R|bas2>;
        test,elt:=IsIsomorphic2(id1,id2 : GRH:=GRH );
		if test then
			U:=Transpose(Matrix(Integers(),[Eltseq(s) :s in Coordinates([elt*b : b in bas2],bas1)]));
			assert2 (U^-1*M1*U) eq M2;
			return test,U;
		else
			return false,_;
		end if;
	end if;
end intrinsic;

